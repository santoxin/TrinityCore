From e1fd63579d1d768f3fd82a625669f714974ddd40 Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Mon, 26 Sep 2016 13:43:07 -0500
Subject: [PATCH] 2016_09_25-New-NPCBots

---
 sql/TrinityCore-Patches/Bots/auth_bots.sql         |   27 +
 sql/TrinityCore-Patches/Bots/character_bots.sql    |   26 +
 sql/TrinityCore-Patches/Bots/world_bots.sql        |  170 +
 .../Database/Implementation/CharacterDatabase.cpp  |   20 +-
 .../Database/Implementation/CharacterDatabase.h    |   15 +-
 .../Database/Implementation/WorldDatabase.cpp      |    5 +
 .../Database/Implementation/WorldDatabase.h        |    5 +
 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp    |  121 +
 src/server/game/AI/NpcBots/bot_Events.h            |  133 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |  724 ++
 src/server/game/AI/NpcBots/bot_ai.cpp              | 8126 ++++++++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |  908 +++
 src/server/game/AI/NpcBots/bot_bm_ai.cpp           |  968 +++
 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp | 1622 ++++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        | 1389 ++++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       | 1086 +++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  910 +++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      | 1173 +++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       | 1066 +++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  828 ++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       | 1340 ++++
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  519 ++
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      | 1915 +++++
 src/server/game/AI/NpcBots/botcommands.cpp         |  931 +++
 src/server/game/AI/NpcBots/botmgr.cpp              |  841 ++
 src/server/game/AI/NpcBots/botmgr.h                |  110 +
 src/server/game/Accounts/RBAC.h                    |   12 +-
 src/server/game/DungeonFinding/LFGMgr.cpp          |  159 +
 src/server/game/Entities/Creature/Creature.cpp     |  465 ++
 src/server/game/Entities/Creature/Creature.h       |   86 +-
 .../game/Entities/Creature/TemporarySummon.cpp     |   10 +
 src/server/game/Entities/Object/Object.cpp         |   15 +
 src/server/game/Entities/Player/KillRewarder.cpp   |   14 +
 src/server/game/Entities/Player/Player.cpp         |  111 +-
 src/server/game/Entities/Player/Player.h           |   27 +-
 src/server/game/Entities/Totem/Totem.cpp           |    7 +
 src/server/game/Entities/Unit/StatSystem.cpp       |    4 +
 src/server/game/Entities/Unit/Unit.cpp             |  561 ++
 src/server/game/Entities/Unit/Unit.h               |   12 +
 src/server/game/Globals/ObjectMgr.cpp              |   76 +
 src/server/game/Globals/ObjectMgr.h                |   20 +
 src/server/game/Groups/Group.cpp                   |   23 +-
 src/server/game/Groups/Group.h                     |    3 +
 src/server/game/Handlers/SpellHandler.cpp          |   30 +
 src/server/game/Maps/Map.cpp                       |   30 +-
 src/server/game/Maps/MapManager.cpp                |   80 +
 src/server/game/Movement/MotionMaster.cpp          |   14 +
 src/server/game/OutdoorPvP/OutdoorPvP.cpp          |   17 +
 src/server/game/Server/WorldSession.cpp            |    4 +
 src/server/game/Spells/Spell.cpp                   |   20 +
 src/server/game/Spells/SpellInfo.cpp               |    5 +
 src/server/game/World/World.cpp                    |    3 +
 src/server/scripts/Commands/cs_npc.cpp             |  103 +
 src/server/scripts/Custom/custom_script_loader.cpp |   34 +-
 src/server/scripts/Spells/spell_paladin.cpp        |   40 +
 src/server/scripts/Spells/spell_priest.cpp         |    4 +
 src/server/worldserver/worldserver.conf.dist       |  122 +
 57 files changed, 27078 insertions(+), 11 deletions(-)
 create mode 100644 sql/TrinityCore-Patches/Bots/auth_bots.sql
 create mode 100644 sql/TrinityCore-Patches/Bots/character_bots.sql
 create mode 100644 sql/TrinityCore-Patches/Bots/world_bots.sql
 create mode 100644 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_Events.h
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_bm_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.h


diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 27dd07d..c0adb9b 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -59,6 +59,10 @@ class PlayerAI;
 
 struct CharacterCustomizeInfo;
 
+// NpcBot mod
+class BotMgr;
+// end NpcBot mod
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2286,7 +2290,20 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
     // 08
     // 09
     // 10
-    // 11
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        void SetBotMgr(BotMgr* mgr) { ASSERT(!_botMgr); _botMgr = mgr; }
+        BotMgr* GetBotMgr() const { return _botMgr; }
+        bool HaveBot() const;
+        uint8 GetNpcBotsCount(bool inWorldOnly = false) const;
+        uint8 GetBotFollowDist() const;
+        void SetBotFollowDist(int8 dist);
+        void SetBotsShouldUpdateStats();
+        void RemoveAllBots(uint8 removetype = 0);
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
     // 12
     // 13
     // 14
@@ -2554,6 +2571,14 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
         bool m_needsZoneUpdate;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        BotMgr* _botMgr;
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index 5e85442..e4778ff 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -146,6 +146,13 @@ void Totem::UnSummon(uint32 msTime)
     if (IsAlive())
         setDeathState(DEAD);
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (GetCreatorGUID().IsCreature())
+        if (Unit* bot = ObjectAccessor::FindConnectedPlayer(GetCreatorGUID()))
+            if (bot->ToCreature()->GetIAmABot())
+                bot->ToCreature()->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index d1984da..6bfe0fa 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -216,6 +216,10 @@ bool Player::UpdateAllStats()
     RecalculateRating(CR_ARMOR_PENETRATION);
     UpdateAllResistances();
 
+    //npcbot - Player::UpdateAllStats() is called on level change - update bots
+    SetBotsShouldUpdateStats();
+    //end npcbot
+
     return true;
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 4581037..9b5aa81 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -278,6 +278,13 @@ Unit::Unit(bool isWorldObject) :
 
     _oldFactionId = 0;
     _isWalkingBeforeCharm = false;
+
+    //npcbot
+    _damageInfo.target = NULL;
+    _delayedTargetGuid.Clear();
+    _swingDelayTimer = 0;
+    _swingLanded = true;
+    //end npcbot
 }
 
 ////////////////////////////////////////////////////////////
@@ -370,6 +377,29 @@ void Unit::Update(uint32 p_time)
         }
     }
 
+    //npcbot: update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI()/* && (!GetVictim() || ToCreature()->IsFreeBot())*/)
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
+    //npcbot:
+    if (_delayedTargetGuid)
+    {
+        if (_swingLanded)
+            _delayedTargetGuid.Clear();
+        else if (_swingDelayTimer >= p_time)
+            _swingDelayTimer -= p_time;
+        else
+            ExecuteDelayedSwingHit();
+    }
+    //end npcbot
+
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
         setAttackTimer(BASE_ATTACK, (p_time >= base_att ? 0 : base_att - p_time));
@@ -608,6 +638,13 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
                 pet->AI()->OwnerAttackedBy(this);
         }
 
+        // NpcBot mod: also signal owned npcbots
+        for (ControlList::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
+            if (Creature* cre = (*itr)->ToCreature())
+                if (cre->IsAIEnabled)
+                    cre->AI()->OwnerAttackedBy(this);
+        // End NpcBot
+
         if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
             return 0;
     }
@@ -881,6 +918,13 @@ void Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo
         TC_LOG_ERROR("entities.unit", "CastSpell: unknown spell by caster: %s %u)", (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUID().GetCounter() : GetEntry()));
         return;
     }
+    //npcbot
+    if (Creature::IsBotCustomSpell(spellInfo->Id) && !(ToCreature() && ToCreature()->GetBotAI()))
+    {
+        TC_LOG_ERROR("entities.unit", "CastSpell: NpcBot system custom spell %u by caster: %s %u), aborted. Please report", spellInfo->Id, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUID().GetCounter() : GetEntry()));
+        return;
+    }
+    //end npcbot
 
     Spell* spell = new Spell(this, spellInfo, triggerFlags, originalCaster);
 
@@ -1032,6 +1076,12 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_RANGED:
             case SPELL_DAMAGE_CLASS_MELEE:
             {
+                //Npcbot mod: apply bot damage mods
+                if (Creature* bot = ToCreature())
+                    if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                        bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+                // End NpcBot
+
                 // Physical Damage
                 if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
                 {
@@ -1089,6 +1139,12 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_NONE:
             case SPELL_DAMAGE_CLASS_MAGIC:
             {
+                //Npcbot mod: apply bot damage mods
+                if (Creature* bot = ToCreature())
+                    if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                        bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+                // End NpcBot
+
                 // If crit add critical bonus
                 if (crit)
                 {
@@ -1215,8 +1271,19 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     else
         damageInfo->damage = damage;
 
+    //NpcBot mod: check custom melee outcome
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        damageInfo->hitOutCome = ToCreature()->BotRollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
+    else
+    //End NpcBot
     damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
 
+    //NpcBot mod: apply bot damage mods
+    if (Creature* bot = ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+    //End NpcBot
+
     switch (damageInfo->hitOutCome)
     {
         case MELEE_HIT_EVADE:
@@ -1431,6 +1498,10 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
 
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->CastItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+    //npcbot - CastItemCombatSpell for bots
+    else if (ToCreature()->GetBotAI())
+        ToCreature()->CastCreatureItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+    //end npcbot
 
     // Do effect if any damage done to target
     if (damageInfo->damage)
@@ -1577,6 +1648,11 @@ uint32 Unit::CalcArmorReducedDamage(Unit* victim, const uint32 damage, SpellInfo
     if (armor < 0.0f)
         armor = 0.0f;
 
+    //npcbot custom armor penetration modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        armor *= std::max<float>(1.0f - ToCreature()->GetCreatureArmorPenetrationCoef(), 0.0f);
+    //end npcbot
+
     float levelModifier = getLevel();
     if (levelModifier > 59)
         levelModifier = levelModifier + 4.5f * (levelModifier - 59);
@@ -1617,6 +1693,10 @@ uint32 Unit::CalcSpellResistance(Unit* victim, SpellSchoolMask schoolMask, Spell
 
     if (Player const* player = ToPlayer())
         baseVictimResistance -= player->GetSpellPenetrationItemMod();
+    //npcbot - spell penetration for bots
+    else if (ToCreature()->GetBotAI())
+        baseVictimResistance -= ToCreature()->GetCreatureSpellPenetration();
+    //end npcbot
 
     // Resistance can't be lower then 0
     int32 victimResistance = std::max<int32>(baseVictimResistance, 0);
@@ -1973,6 +2053,38 @@ void Unit::CalcHealAbsorb(Unit* victim, SpellInfo const* healSpell, uint32 &heal
     healAmount = RemainingHeal;
 }
 
+//NpcBot mod
+void Unit::ExecuteDelayedSwingHit(bool extra)
+{
+    if (_swingLanded)
+        return;
+
+    _swingLanded = true;
+    if (!extra)
+        _damageInfo.target = ObjectAccessor::FindConnectedPlayer(_delayedTargetGuid);
+
+    if (!_damageInfo.target)
+        return;
+
+    //TC_LOG_DEBUG(LOG_FILTER_UNITS, "Unit::ExecuteDelayedSwingHit() call for %s, victim = %s", GetName().c_str(), _damageInfo.target->GetName().c_str());
+
+    //TriggerAurasProcOnEvent(*_damageInfo);
+    DealMeleeDamage(&_damageInfo, true);
+
+    // Recursion warning here
+    ProcDamageAndSpell(_damageInfo.target, _damageInfo.procAttacker, _damageInfo.procVictim, _damageInfo.procEx, _damageInfo.damage, _damageInfo.attackType);
+}
+//NpcBot mod
+void Unit::SuspendDelayedSwing()
+{
+    if (_swingLanded)
+        return;
+
+    _swingLanded = true;
+    //TC_LOG_DEBUG(LOG_FILTER_UNITS, "Unit::SuspendDelayedSwing() call for %s, victim = %s", GetName().c_str(), _damageInfo.target ? _damageInfo.target->GetName().c_str() : "_removed_");
+}
+//End NpcBot mod
+
 void Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool extra)
 {
     if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
@@ -1984,6 +2096,48 @@ void Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool ext
     if ((attType == BASE_ATTACK || attType == OFF_ATTACK) && !IsWithinLOSInMap(victim))
         return;
 
+    //npcbot
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+    {
+        // if attack is executed before previous swing finished, finish it forcefully
+        ExecuteDelayedSwingHit();
+
+        CombatStart(victim);
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
+
+        if (attType != BASE_ATTACK && attType != OFF_ATTACK)
+            return;                                             // ignore ranged case
+
+        // melee attack spell casted at main hand attack only - no normal melee dmg dealt
+        if (attType == BASE_ATTACK && m_currentSpells[CURRENT_MELEE_SPELL] && !extra)
+            m_currentSpells[CURRENT_MELEE_SPELL]->cast();
+        else
+        {
+            // attack can be redirected to another target
+            victim = GetMeleeHitRedirectTarget(victim);
+            CalculateMeleeDamage(victim, 0, &_damageInfo, attType);
+            DealDamageMods(victim, _damageInfo.damage, &_damageInfo.absorb);
+
+            // Send log damage message to client
+            SendAttackStateUpdate(&_damageInfo);
+
+            // If this swing is extra attack, execute it right now
+            // Else delay melee hit by melee swing animation time
+            _swingLanded = false;
+            _delayedTargetGuid = victim->GetGUID();
+            if (m_extraAttacks)
+                ExecuteDelayedSwingHit(true);
+            else
+                _swingDelayTimer = 450;
+
+            //TC_LOG_DEBUG("entities.unit", "AttackerStateUpdateBot: (NPCBot)    %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
+            //    GetGUID().GetCounter(), victim->GetGUID().GetCounter(), victim->GetTypeId(), _damageInfo.damage, _damageInfo.absorb, _damageInfo.blocked_amount, _damageInfo.resist);
+        }
+
+        return;
+    }
+    //end npcbot
+
     CombatStart(victim);
     RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
 
@@ -2094,11 +2248,24 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
     {
         TC_LOG_DEBUG("entities.unit", "RollMeleeOutcomeAgainst: attack came from behind and victim was a player.");
     }
+    //npcbot - bots cannot dodge if attacker is behind
+    else if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotAI() && !victim->HasInArc(M_PI, this) && !victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        //TC_LOG_DEBUG("entities.unit", "RollMeleeOutcomeAgainst: attack came from behind and victim was a bot.");
+    }
+    //end npcbot
     else
     {
         // Reduce dodge chance by attacker expertise rating
         if (GetTypeId() == TYPEID_PLAYER)
             dodge_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        //npcbot - manual expertise instead of auras
+        else if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        {
+            dodge_chance -= ToCreature()->GetCreatureExpertise() * 25;
+            dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        }
+        //end npcbot
         else
             dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
 
@@ -2126,6 +2293,13 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
         // Reduce parry chance by attacker expertise rating
         if (GetTypeId() == TYPEID_PLAYER)
             parry_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        //npcbot - manual expertise instead of auras
+        else if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        {
+            parry_chance -= ToCreature()->GetCreatureExpertise() * 25;
+            parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        }
+        //end npcbot
         else
             parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
 
@@ -2729,6 +2903,14 @@ float Unit::GetUnitDodgeChance() const
         else
         {
             float dodge = 5.0f;
+            //npcbot - custom dodge chance instead of bunch of auras and remove base chance
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanDodge())
+                    return 0.0f;
+                dodge = ToCreature()->GetCreatureDodgeChance();
+            }
+            //end npcbot
             dodge += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
             return dodge > 0.0f ? dodge : 0.0f;
         }
@@ -2758,6 +2940,15 @@ float Unit::GetUnitParryChance() const
     {
         if (GetCreatureType() == CREATURE_TYPE_HUMANOID)
         {
+            //npcbot - custom parry chance instead of bunch of auras
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanParry())
+                    return 0.0f;
+                chance = ToCreature()->GetCreatureParryChance();
+            }
+            else
+            //end npcbot
             chance = 5.0f;
             chance += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
         }
@@ -2804,6 +2995,14 @@ float Unit::GetUnitBlockChance() const
         else
         {
             float block = 5.0f;
+            //npcbot - custom block chance instead of bunch of auras and remove base chance
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanBlock())
+                    return 0.0f;
+                block = ToCreature()->GetCreatureBlockChance();
+            }
+            //end npcbot
             block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
             return block > 0.0f ? block : 0.0f;
         }
@@ -2835,6 +3034,15 @@ float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victi
     }
     else
     {
+        //npcbot - custom crit chance instead of bunch of auras and remove base chance
+        if (ToCreature()->GetBotAI())
+        {
+            if (!ToCreature()->CanCrit())
+                return 0.0f;
+            crit = 5.0f + ToCreature()->GetCreatureCritChance();
+        }
+        else
+        //end npcbot
         crit = 5.0f;
         crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
         crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
@@ -6205,6 +6413,12 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                     // Check cooldown of heal spell cooldown
                     if (!GetSpellHistory()->HasCooldown(34299))
                         CastCustomSpell(this, 68285, &basepoints1, 0, 0, true, 0, triggeredByAura);
+
+                    //npcbot - proc for bot
+                    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI() && !ToCreature()->GetSpellHistory()->HasCooldown(34299))
+                        CastCustomSpell(this, 68285, &basepoints1, 0, 0, true, 0, triggeredByAura);
+                    //end npcbot
+
                     break;
                 }
                 // Healing Touch (Dreamwalker Raiment set)
@@ -6317,6 +6531,31 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                     return true;
                 }
             }
+
+            //npcbot - Eclipse for bot
+            if (dummySpell->SpellIconID == 2856 && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+            {
+                if (!procSpell || effIndex != 0)
+                    return false;
+
+                bool isWrathSpell = (procSpell->SpellFamilyFlags[0] & 1);
+
+                if (!roll_chance_f(dummySpell->ProcChance * (isWrathSpell ? 0.6f : 1.0f)))
+                    return false;
+
+                target = this;
+                if (target->HasAura(isWrathSpell ? 48517 : 48518))
+                    return false;
+
+                triggered_spell_id = isWrathSpell ? 48518 : 48517;
+
+                if (ToCreature()->GetSpellHistory()->HasCooldown(triggered_spell_id))
+                    return false;
+
+                break;
+            }
+            //end npcbot
+
             break;
         }
         case SPELLFAMILY_ROGUE:
@@ -8608,6 +8847,9 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
     //    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
 
     if (GetTypeId() == TYPEID_UNIT && !IsPet())
+    //npcbot - not for npcbots either
+    if (!ToCreature()->GetBotAI())
+    //end npcbot
     {
         // should not let player enter combat by right clicking target - doesn't helps
         AddThreat(victim, 0.0f);
@@ -8682,6 +8924,9 @@ void Unit::CombatStop(bool includingCast)
         InterruptNonMeleeSpells(false);
 
     AttackStop();
+    //npcbot
+    SuspendDelayedSwing();
+    //end npcbot
     RemoveAllAttackers();
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel
@@ -8719,6 +8964,9 @@ void Unit::RemoveAllAttackers()
     while (!m_attackers.empty())
     {
         AttackerSet::iterator iter = m_attackers.begin();
+        //npcbot
+        (*iter)->SuspendDelayedSwing();
+        //end npcbot
         if (!(*iter)->AttackStop())
         {
             TC_LOG_ERROR("entities.unit", "WORLD: Unit has an attacker that isn't attacking it!");
@@ -9309,12 +9557,25 @@ void Unit::RemoveAllControlled()
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->StopCastingCharm();
 
+    //npcbot - store bots for recontroll; bots are to be removed manually
+    std::list<Unit*> nBots;
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        if ((*itr)->GetTypeId() == TYPEID_UNIT && (*itr)->ToCreature()->GetBotAI())
+            nBots.push_back(*itr);
+    //end npcbot
+
     while (!m_Controlled.empty())
     {
         Unit* target = *m_Controlled.begin();
         m_Controlled.erase(m_Controlled.begin());
         if (target->GetCharmerGUID() == GetGUID())
             target->RemoveCharmAuras();
+        //npcbot - debug info
+        else if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->GetBotAI())
+        {
+            //TC_LOG_ERROR("entities.unit", "RemoveAllControlled(): Unit %u removing bot %s (%u)", GetGUID().GetCounter(), target->GetName().c_str(), target->GetEntry());
+        }
+        //end npcbot
         else if (target->GetOwnerGUID() == GetGUID() && target->IsSummon())
             target->ToTempSummon()->UnSummon();
         else
@@ -9326,6 +9587,14 @@ void Unit::RemoveAllControlled()
         TC_LOG_FATAL("entities.unit", "Unit %u is not able to release its minion %s", GetEntry(), GetMinionGUID().ToString().c_str());
     if (GetCharmGUID())
         TC_LOG_FATAL("entities.unit", "Unit %u is not able to release its charm %s", GetEntry(), GetCharmGUID().ToString().c_str());
+
+    //npcbot - restore controlled bots
+    if (nBots.empty())
+        return;
+
+    for (std::list<Unit*>::const_iterator itr = nBots.begin(); itr != nBots.end(); ++itr)
+        m_Controlled.insert(*itr);
+    //end npcbot
 }
 
 bool Unit::isPossessedByPlayer() const
@@ -9948,6 +10217,11 @@ uint32 Unit::SpellDamageBonusTaken(Unit* caster, SpellInfo const* spellProto, ui
                 AddPct(TakenTotalMod, (*i)->GetAmount());
     }
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        TakenTotalMod *= ToCreature()->GetCreatureDamageTakenMod();
+    //end npcbot
+
     //.. taken pct: dummy auras
     AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
     for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
@@ -10038,6 +10312,11 @@ int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask) const
 {
     int32 DoneAdvertisedBenefit = 0;
 
+    //npcbot: apply bot spellpower
+    if (schoolMask && !(schoolMask & SPELL_SCHOOL_MASK_NORMAL) && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        DoneAdvertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     AuraEffectList const& mDamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
     for (AuraEffectList::const_iterator i = mDamageDone.begin(); i != mDamageDone.end(); ++i)
         if (((*i)->GetMiscValue() & schoolMask) != 0 &&
@@ -10095,6 +10374,9 @@ float Unit::GetUnitSpellCriticalChance(Unit* victim, SpellInfo const* spellProto
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (GetGUID().IsCreatureOrVehicle() && !(IsTotem() && GetOwnerGUID().IsPlayer()) && GetEntry() != 15438)
+        //npcbot - allow bots to crit
+        if (!ToCreature()->GetBotAI())
+        //end npcbot
         return 0.0f;
 
     // not critting spell
@@ -10299,6 +10581,11 @@ float Unit::GetUnitSpellCriticalChance(Unit* victim, SpellInfo const* spellProto
         }
     }
 
+    //npcbot - apply bot spell crit mods
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyBotCritMultiplierAll(victim, crit_chance, spellProto, schoolMask, attackType);
+    //end npcbot
+
     return crit_chance > 0.0f ? crit_chance : 0.0f;
 }
 
@@ -10477,6 +10764,11 @@ uint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, ui
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
 
+    //npcbot - healing bonus done for bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyBotDamageMultiplierHeal(victim, heal, spellProto, damagetype, stack);
+    //end npcbot
+
     return uint32(std::max(heal, 0.0f));
 }
 
@@ -10665,6 +10957,11 @@ int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask) const
         if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
             advertisedBenefit += (*i)->GetAmount();
 
+    //npcbot: apply bot spellpower to healing
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        advertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -10756,6 +11053,11 @@ bool Unit::IsImmunedToSpell(SpellInfo const* spellInfo) const
     if (spellInfo->HasAttribute(SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY))
         return false;
 
+    //npcbot - check 'magic immunity' state and other
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI() && ToCreature()->IsCreatureImmuneToSpell(spellInfo))
+        return true;
+    //end npcbot
+
     if (spellInfo->Dispel)
     {
         SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];
@@ -11077,6 +11379,11 @@ uint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackT
     // ..taken
     TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, attacker->GetMeleeDamageSchoolMask());
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        TakenTotalMod *= ToCreature()->GetCreatureDamageTakenMod();
+    //end npcbot
+
     // .. taken pct (special attacks)
     if (spellProto)
     {
@@ -11418,6 +11725,12 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
     if (PvP)
         m_CombatTimer = 5000;
 
+    ////npcbot - if combat with npcbot or its pet set extended timer
+    //if (PvP &&((GetTypeId() == TYPEID_UNIT && ToCreature()->IsFreeBot()) ||
+    //    (enemy->GetTypeId() == TYPEID_UNIT && enemy->ToCreature()->IsFreeBot())))
+    //    m_CombatTimer += 5000;
+    ////end npcbot
+
     if (IsInCombat() || HasUnitState(UNIT_STATE_EVADE))
         return;
 
@@ -11844,6 +12157,12 @@ bool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const
                 if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
                     return true;
 
+    //npcbot - bots are always visible for owner
+    if (Creature const* bot = ToCreature())
+        if (bot->GetBotAI() && seer->GetGUID() == bot->GetBotOwner()->GetGUID())
+            return true;
+    //end npcbot
+
     return false;
 }
 
@@ -12187,6 +12506,11 @@ bool Unit::CanHaveThreatList(bool skipAliveCheck) const
     if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && ((Pet*)this)->GetOwnerGUID().IsPlayer())
         return false;
 
+    //npcbot - npcbots and their pets cannot have threatlist
+    if (ToCreature()->GetBotAI())
+        return false;
+    //end npcbot
+
     return true;
 }
 
@@ -12573,6 +12897,10 @@ void Unit::ModSpellCastTime(SpellInfo const* spellInfo, int32 & castTime, Spell*
     // called from caster
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CASTING_TIME, castTime, spell);
+    //npcbot - apply bot spell cast time mods
+    if (castTime > 0 && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyCreatureSpellCastTimeMods(spellInfo, castTime);
+    //end npcbot
 
     if (!(spellInfo->HasAttribute(SPELL_ATTR0_ABILITY) || spellInfo->HasAttribute(SPELL_ATTR0_TRADESPELL) || spellInfo->HasAttribute(SPELL_ATTR3_NO_DONE_BONUS)) &&
         ((GetTypeId() == TYPEID_PLAYER && spellInfo->SpellFamilyName) || GetTypeId() == TYPEID_UNIT))
@@ -13818,6 +14146,13 @@ void Unit::ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, u
                     ToPlayer()->AddComboPoints(target, 1);
                     StartReactiveTimer(REACTIVE_OVERPOWER);
                 }
+
+                //npcbot - update reactives for bots
+                if ((procExtra & (PROC_EX_DODGE | PROC_EX_PARRY)) && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI() && ToCreature()->GetBotClass() == CLASS_WARRIOR)
+                {
+                    StartReactiveTimer(REACTIVE_OVERPOWER);
+                }
+                //end npcbot
             }
         }
     }
@@ -14397,6 +14732,29 @@ void Unit::ClearComboPointHolders()
     }
 }
 
+//npcbot
+void Unit::ClearReactive(ReactiveType reactive)
+{
+    m_reactiveTimer[reactive] = 0;
+
+    switch (reactive)
+    {
+        case REACTIVE_DEFENSE:
+            if (HasAuraState(AURA_STATE_DEFENSE))
+                ModifyAuraState(AURA_STATE_DEFENSE, false);
+            break;
+        case REACTIVE_HUNTER_PARRY:
+            if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+                ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+            break;
+        case REACTIVE_OVERPOWER:
+            if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
+                ToPlayer()->ClearComboPoints();
+            break;
+    }
+}
+//end npcbot
+
 void Unit::ClearAllReactives()
 {
     for (uint8 i = 0; i < MAX_REACTIVE; ++i)
@@ -14505,6 +14863,9 @@ uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectTyp
 {
     // Not apply this to creature cast spells with casttime == 0
     if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !IsPet())
+        //npcbot - skip bots
+        if (!ToCreature()->GetBotAI())
+        //endnpcbot
         return 3500;
 
     if (CastingTime > 7000) CastingTime = 7000;
@@ -15147,6 +15508,9 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
 
         // only if not player and not controlled by player pet. And not at BG
         if ((durabilityLoss && !player && !victim->ToPlayer()->InBattleground()) || (player && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
+        //npcbot - bots should not cause durability loss unless rampaging around
+        if (player || !ToCreature()->GetBotAI() || ToCreature()->GetBotOwner()->GetGUID().GetCounter() == GetGUID().GetCounter())
+        //end npcbot
         {
             TC_LOG_DEBUG("entities.unit", "We are dead, losing %f percent durability", sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH));
             plrVictim->DurabilityLossAll(sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH), false);
@@ -16104,6 +16468,21 @@ float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, i
     //calculate miss chance
     float missChance = victim->GetUnitMissChance(attType);
 
+    //npcbot - custom miss chance instead of bunch of auras, extra miss chance against bots
+    //bot can have extra miss chance for attackers
+    //but if attacker is also a bot and cannot miss then return this extra miss chance
+    float evasion = 0.0f;
+
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotAI())
+        evasion = victim->ToCreature()->GetCreatureEvasion();
+    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->CanMiss())
+        return evasion;
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        missChance += ToCreature()->GetCreatureMissChance();
+
+    missChance += evasion;
+    //end npcbot
+
     if (!spellId && haveOffhandWeapon())
         missChance += 19;
 
@@ -16132,6 +16511,11 @@ float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, i
     else
         missChance -= m_modMeleeHitChance;
 
+    //npcbot - limit chance from 30% to 60% if evasion is here
+    if (evasion > 0.0f && missChance < evasion)
+        missChance = evasion;
+    //end npcbot
+
     // Limit miss chance from 0 to 60%
     if (missChance < 0.0f)
         return 0.0f;
@@ -16448,6 +16832,183 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
         }
     }
 
+    else if (ToCreature() && ToCreature()->GetBotOwner() && ToCreature()->GetBotOwner()->ToPlayer())
+    {
+        Player const* player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+        case FORM_CAT:
+            // Based on master's Hair color
+            if (player->getRace() == RACE_NIGHTELF)
+            {
+                uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                switch (hairColor)
+                {
+                case 7: // Violet
+                case 8:
+                    return 29405;
+                case 3: // Light Blue
+                    return 29406;
+                case 0: // Green
+                case 1: // Light Green
+                case 2: // Dark Green
+                    return 29407;
+                case 4: // White
+                    return 29408;
+                default: // original - Dark Blue
+                    return 892;
+                }
+            }
+            // Based on master's Skin color
+            else if (player->getRace() == RACE_TAUREN)
+            {
+                uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                // Male master
+                if (player->getGender() == GENDER_MALE)
+                {
+                    switch (skinColor)
+                    {
+                    case 12: // White
+                    case 13:
+                    case 14:
+                    case 18: // Completly White
+                        return 29409;
+                    case 9: // Light Brown
+                    case 10:
+                    case 11:
+                        return 29410;
+                    case 6: // Brown
+                    case 7:
+                    case 8:
+                        return 29411;
+                    case 0: // Dark
+                    case 1:
+                    case 2:
+                    case 3: // Dark Grey
+                    case 4:
+                    case 5:
+                        return 29412;
+                    default: // original - Grey
+                        return 8571;
+                    }
+                }
+                // Female master
+                else switch (skinColor)
+                {
+                case 10: // White
+                    return 29409;
+                case 6: // Light Brown
+                case 7:
+                    return 29410;
+                case 4: // Brown
+                case 5:
+                    return 29411;
+                case 0: // Dark
+                case 1:
+                case 2:
+                case 3:
+                    return 29412;
+                default: // original - Grey
+                    return 8571;
+                }
+            }
+            else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                return 892;
+            else
+                return 8571;
+        case FORM_DIREBEAR:
+        case FORM_BEAR:
+            // Based on Hair color
+            if (player->getRace() == RACE_NIGHTELF)
+            {
+                uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                switch (hairColor)
+                {
+                case 0: // Green
+                case 1: // Light Green
+                case 2: // Dark Green
+                    return 29413; // 29415?
+                case 6: // Dark Blue
+                    return 29414;
+                case 4: // White
+                    return 29416;
+                case 3: // Light Blue
+                    return 29417;
+                default: // original - Violet
+                    return 2281;
+                }
+            }
+            // Based on Skin color
+            else if (player->getRace() == RACE_TAUREN)
+            {
+                uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                // Male
+                if (player->getGender() == GENDER_MALE)
+                {
+                    switch (skinColor)
+                    {
+                    case 0: // Dark (Black)
+                    case 1:
+                    case 2:
+                        return 29418;
+                    case 3: // White
+                    case 4:
+                    case 5:
+                    case 12:
+                    case 13:
+                    case 14:
+                        return 29419;
+                    case 9: // Light Brown/Grey
+                    case 10:
+                    case 11:
+                    case 15:
+                    case 16:
+                    case 17:
+                        return 29420;
+                    case 18: // Completly White
+                        return 29421;
+                    default: // original - Brown
+                        return 2289;
+                    }
+                }
+                // Female
+                else switch (skinColor)
+                {
+                case 0: // Dark (Black)
+                case 1:
+                    return 29418;
+                case 2: // White
+                case 3:
+                    return 29419;
+                case 6: // Light Brown/Grey
+                case 7:
+                case 8:
+                case 9:
+                    return 29420;
+                case 10: // Completly White
+                    return 29421;
+                default: // original - Brown
+                    return 2289;
+                }
+            }
+            else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                return 2281;
+            else
+                return 2289;
+        case FORM_FLIGHT:
+            if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                return 20857;
+            return 20872;
+        case FORM_FLIGHT_EPIC:
+            if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                return 21243;
+            return 21244;
+        default:
+            break;
+        }
+    }
+
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
     if (formEntry && formEntry->modelID_A)
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index aa23257..f17138a 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -2184,6 +2184,18 @@ class TC_GAME_API Unit : public WorldObject
         virtual void TextEmote(uint32 textId, WorldObject const* target = nullptr, bool isBossEmote = false);
         virtual void Whisper(uint32 textId, Player* target, bool isBossWhisper = false);
 
+        //npcbot
+        bool HasReactive(ReactiveType reactive) const { return m_reactiveTimer[reactive] > 0; }
+        void ClearReactive(ReactiveType reactive);
+
+        void SuspendDelayedSwing();
+        void ExecuteDelayedSwingHit(bool extra = false);
+        CalcDamageInfo _damageInfo;
+        ObjectGuid _delayedTargetGuid;
+        uint32 _swingDelayTimer;
+        bool _swingLanded;
+        //end npcbot
+
     protected:
         explicit Unit (bool isWorldObject);
 
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 781d30f..d59ebac 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -8059,6 +8059,82 @@ SkillRangeType GetSkillRangeType(SkillRaceClassInfoEntry const* rcEntry)
     return SKILL_RANGE_LEVEL;
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_f;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_m;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index ea0a4da..47b5180 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -136,6 +136,21 @@ struct GameTele
 
 typedef std::unordered_map<uint32, GameTele > GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+typedef std::unordered_map<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -1037,6 +1052,7 @@ class TC_GAME_API ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1251,6 +1267,8 @@ class TC_GAME_API ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string const& name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         TrainerSpellData const* GetNpcTrainerSpells(uint32 entry) const
         {
             CacheTrainerSpellContainer::const_iterator  iter = _cacheTrainerSpellStore.find(entry);
@@ -1403,6 +1421,8 @@ class TC_GAME_API ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void LoadQuestRelationsHelper(QuestRelations& map, QuestRelationsReverse* reverseMap, std::string const& table, bool starter, bool go);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index ccfd484..56503a6 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -105,6 +105,11 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    //npcbot - set loot mode on create
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
+    //end npcbot
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -363,6 +368,10 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    //npcbot - check if trying to add bot
+    if (player->GetGUID().IsPlayer())
+    {
+    //end npcbot
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -376,7 +385,9 @@ bool Group::AddMember(Player* player)
 
     // if the same group invites the player back, cancel the homebind timer
     player->m_InstanceValid = player->CheckInstanceValidity(false);
-
+    //npcbot
+    }
+    //end npcbot
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
         for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
@@ -400,6 +411,10 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    //npcbot - check 2
+    if (player->GetGUID().IsPlayer())
+    {
+    //end npcbot
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -475,6 +490,9 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    //npcbot
+    }
+    //end npcbot
 
     return true;
 }
@@ -613,6 +631,9 @@ bool Group::RemoveMember(ObjectGuid guid, const RemoveMethod& method /*= GROUP_R
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index 18b8119..9f65a9e 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -324,6 +324,9 @@ class TC_GAME_API Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        ObjectGuid const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(ObjectGuid guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index cbc9be3..e7b2d55 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -576,8 +576,38 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //bot
+    if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->getClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+    }
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
+    //end bot
 
     // Get creator of the unit (SPELL_AURA_CLONE_CASTER does not stack)
     Unit* creator = unit->GetAuraEffectsByType(SPELL_AURA_CLONE_CASTER).front()->GetCaster();
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 177691c..42fccdd 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -37,6 +37,10 @@
 #include "Vehicle.h"
 #include "VMapFactory.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 u_map_magic MapMagic        = { {'M','A','P','S'} };
 u_map_magic MapVersionMagic = { {'v','1','.','8'} };
 u_map_magic MapAreaMagic    = { {'A','R','E','A'} };
@@ -2890,8 +2894,24 @@ uint32 Map::GetPlayersCountExceptGMs() const
 {
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
-        if (!itr->GetSource()->IsGameMaster())
+        if (!itr->GetSource()->IsGameMaster()) {
+            //npcbot - count npcbots as group members (event if not in group)
+            if (itr->GetSource()->HaveBot() && BotMgr::LimitBots(this))
+            {
+                ++count;
+                BotMap const* botmap = itr->GetSource()->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = botmap->begin(); itr != botmap->end(); ++itr)
+                {
+                    Creature* cre = itr->second;
+                    if (!cre || !cre->IsInWorld() || cre->FindMap() != this)
+                        continue;
+                    ++count;
+                }
+            }
+            else
+            //end npcbot
             ++count;
+        }
     return count;
 }
 
@@ -2957,6 +2977,10 @@ void Map::AddToActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->incUnloadActiveLock();
+        //bot
+        else if (c->GetIAmABot())
+            EnsureGridLoadedForActiveObject(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())), c);
+        //end bot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
@@ -2988,6 +3012,10 @@ void Map::RemoveFromActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->decUnloadActiveLock();
+        //bot
+        else if (c->GetIAmABot())
+            EnsureGridLoaded(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())));
+        //end bot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
diff --git a/src/server/game/Maps/MapManager.cpp b/src/server/game/Maps/MapManager.cpp
index 79a8b38..3fe7fc6 100644
--- a/src/server/game/Maps/MapManager.cpp
+++ b/src/server/game/Maps/MapManager.cpp
@@ -37,6 +37,10 @@
 #include "Opcodes.h"
 #include "AchievementMgr.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 MapManager::MapManager()
     : _nextInstanceId(0), _scheduledScripts(0)
 {
@@ -54,6 +58,82 @@ void MapManager::Initialize()
     // Start mtmaps if needed.
     if (num_threads > 0)
         m_updater.activate(num_threads);
+
+    //npcbot - spawn bots
+    BotMgr::LoadConfig();
+
+    if (!BotMgr::IsNpcBotModEnabled())
+        return;
+
+    uint32 botoldMSTime = getMSTime();
+
+    TC_LOG_INFO("server.loading", "Starting NpcBot system...");
+    PreparedStatement* botstmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOTS);
+    //"SELECT entry FROM characters_npcbot", CONNECTION_SYNCH
+    PreparedQueryResult res = CharacterDatabase.Query(botstmt);
+    if (!res)
+    {
+        TC_LOG_INFO("server.loading", ">> Spawned 0 npcbots. Table `characters_npcbot` is empty!");
+        return;
+    }
+
+    PreparedQueryResult infores;
+    uint32 botcounter = 0;
+    Field* field;
+    std::list<uint32> botgrids;
+    do
+    {
+        field = res->Fetch();
+        uint32 entry = field[0].GetUInt32();
+        CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(entry);
+        if (!proto)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot find creature_template entry for npcbot (id: %u)!", entry);
+            continue;
+        }
+
+        botstmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_INFO);
+        //"SELECT guid, map, position_x, position_y, position_z, orientation FROM creature WHERE id = ?", CONNECTION_SYNCH
+        botstmt->setUInt32(0, entry);
+        infores = WorldDatabase.Query(botstmt);
+        if (!infores)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot spawn npcbot %s (id: %u), not found in `creature` table!", proto->Name.c_str(), entry);
+            continue;
+        }
+
+        field = infores->Fetch();
+        uint32 tableGuid = field[0].GetUInt32();
+        uint32 mapId = uint32(field[1].GetUInt16());
+        float pos_x = field[2].GetFloat();
+        float pos_y = field[3].GetFloat();
+        //float pos_z = field[4].GetFloat();
+        //float ori = field[5].GetFloat();
+
+        CellCoord c = Trinity::ComputeCellCoord(pos_x, pos_y);
+        GridCoord g = Trinity::ComputeGridCoord(pos_x, pos_y);
+        ASSERT(c.IsCoordValid() && "Invalid Cell coord!");
+        ASSERT(g.IsCoordValid() && "Invalid Grid coord!");
+        Map* npcbotmap = sMapMgr->CreateBaseMap(mapId);
+        npcbotmap->LoadGrid(pos_x, pos_y);
+        /*Creature* bot = npcbotmap->GetCreature(ObjectGuid(HighGuid::Unit, entry, tableGuid));
+        ABORT();
+        //debug
+        if (!bot->IsAlive())
+        {
+            bot->Respawn();
+            bot->ResetBotAI(1);
+        }*/
+
+        TC_LOG_DEBUG("server.loading", ">> Spawned npcbot %s (id: %u, map: %u, grid: %u, cell: %u)", proto->Name.c_str(), entry, mapId, g.GetId(), c.GetId());
+        botgrids.push_back(g.GetId());
+        ++botcounter;
+
+    } while (res->NextRow());
+
+    botgrids.unique();
+    TC_LOG_INFO("server.loading", ">> Spawned %u npcbot(s) within %lu grid(s) in %u ms", botcounter, botgrids.size(), GetMSTimeDiffToNow(botoldMSTime));
+    //end npcbot
 }
 
 void MapManager::InitializeVisibilityDistanceInfo()
diff --git a/src/server/game/Movement/MotionMaster.cpp b/src/server/game/Movement/MotionMaster.cpp
index 4ad2a31..cb7b159 100644
--- a/src/server/game/Movement/MotionMaster.cpp
+++ b/src/server/game/Movement/MotionMaster.cpp
@@ -386,6 +386,20 @@ void MotionMaster::MoveJumpTo(float angle, float speedXY, float speedZ)
 
     float x, y, z;
 
+    //npcbot
+    if (_owner->GetTypeId() == TYPEID_UNIT && _owner->ToCreature()->IsNPCBot())
+    {
+        Movement::MoveSplineInit init(_owner);
+        init.MoveTo(x, y, z);
+        init.SetParabolic(speedZ/*max_height*/, 0);
+        init.SetOrientationFixed(true);
+        init.SetVelocity(speedXY);
+        init.Launch();
+        Mutate(new EffectMovementGenerator(0), MOTION_SLOT_CONTROLLED);
+        return;
+    }
+    //end npcbot
+
     float moveTimeHalf = speedZ / Movement::gravity;
     float dist = 2 * moveTimeHalf * speedXY;
     _owner->GetClosePoint(x, y, z, _owner->GetObjectSize(), dist, angle);
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.cpp b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
index 1343e09..b11c193 100644
--- a/src/server/game/OutdoorPvP/OutdoorPvP.cpp
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
@@ -346,6 +346,23 @@ bool OPvPCapturePoint::Update(uint32 diff)
     if (!fact_diff)
         return false;
 
+    //npcbots - count bots as players but 2 times less affect and only if there is a players difference
+    uint32 botsCount[2];
+
+    for (uint8 team = 0; team != 2; ++team)
+    {
+        botsCount[team] = 0;
+
+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+            if (Player* player = ObjectAccessor::FindPlayer(*itr))
+                botsCount[team] += player->GetNpcBotsCount();
+        }
+    }
+
+    fact_diff += 0.5f * float(botsCount[0] - botsCount[1]) * diff / OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+    //end npcbot
+
     uint32 Challenger = 0;
     float maxDiff = m_maxSpeed * diff;
 
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 3ecd3f2..6e1b7e4 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -438,6 +438,10 @@ void WorldSession::LogoutPlayer(bool save)
     m_playerLogout = true;
     m_playerSave = save;
 
+    //npcbot - free all bots and remove from botmap
+    _player->RemoveAllBots();
+    //end npcbots
+
     if (_player)
     {
         if (ObjectGuid lguid = _player->GetLootGUID())
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 8332219..0bb50ed 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -2431,6 +2431,13 @@ void Spell::DoAllEffectOnTarget(TargetInfo* target)
             if (caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->HasAttribute(SPELL_ATTR0_STOP_ATTACK_TARGET) == 0 &&
                (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
                 caster->ToPlayer()->CastItemCombatSpell(unitTarget, m_attackType, procVictim, procEx);
+
+            //npcbot - CastItemCombatSpell for bots
+            if (caster->GetTypeId() == TYPEID_UNIT &&
+                caster->ToCreature()->GetBotAI() && !(m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET) &&
+               (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
+               caster->ToCreature()->CastCreatureItemCombatSpell(unitTarget, m_attackType, procVictim, procEx, this);
+            //end npcbot
         }
 
         m_damage = damageInfo.damage;
@@ -3212,6 +3219,11 @@ void Spell::cast(bool skipCheck)
         if (Creature* pet = ObjectAccessor::GetCreature(*m_caster, m_caster->GetPetGUID()))
             pet->DespawnOrUnsummon();
 
+    //NpcBot: If we are applying crowd control aura execute caster's delayed attack immediately to prevent instant CC break
+    if (m_targets.GetUnitTarget() && (m_spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE))
+        m_caster->ExecuteDelayedSwingHit();
+    //end NpcBot
+
     PrepareTriggersExecutedOnHit();
 
     CallScriptOnCastHandlers();
@@ -3671,6 +3683,9 @@ void Spell::finish(bool ok)
 
     // Stop Attack for some spells
     if (m_spellInfo->HasAttribute(SPELL_ATTR0_STOP_ATTACK_TARGET))
+    //npcbot - disable for npcbots
+    if (!(m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->GetBotAI()))
+    //end npcbot
         m_caster->AttackStop();
 }
 
@@ -3886,6 +3901,11 @@ void Spell::SendSpellStart()
 
 void Spell::SendSpellGo()
 {
+    //npcbot - hook for spellcast finish
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->GetBotAI())
+        m_caster->ToCreature()->OnSpellGo(this);
+    //end npcbot
+
     // not send invisible spell casting
     if (!IsNeedSendToClient())
         return;
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index eba950a..e888957 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -2265,6 +2265,11 @@ int32 SpellInfo::CalcPowerCost(Unit const* caster, SpellSchoolMask schoolMask) c
         }
     }
 
+    //npcbot - apply bot spell cost mods
+    if (powerCost > 0 && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->GetBotAI())
+        caster->ToCreature()->ApplyCreatureSpellCostMods(this, powerCost);
+    //end npcbot
+
     // PCT mod from user auras by school
     powerCost = int32(powerCost * (1.0f + caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER + school)));
     if (powerCost < 0)
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index ad29af4..e9a74cb 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1619,6 +1619,9 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Loading Creature templates...");
     sObjectMgr->LoadCreatureTemplates();
 
+    TC_LOG_INFO("server.loading", "Loading Creature template outfits...");     // must be after LoadCreatureTemplates
+    sObjectMgr->LoadCreatureOutfits();
+
     TC_LOG_INFO("server.loading", "Loading Equipment templates...");           // must be after LoadCreatureTemplates
     sObjectMgr->LoadEquipmentTemplates();
 
diff --git a/src/server/scripts/Commands/cs_npc.cpp b/src/server/scripts/Commands/cs_npc.cpp
index 3b495c8..a8b49ad 100644
--- a/src/server/scripts/Commands/cs_npc.cpp
+++ b/src/server/scripts/Commands/cs_npc.cpp
@@ -32,6 +32,8 @@ EndScriptData */
 #include "CreatureAI.h"
 #include "Player.h"
 #include "Pet.h"
+#include "bot_ai.h"
+#include "botmgr.h"
 
 template<typename E, typename T = char const*>
 struct EnumName
@@ -243,6 +245,16 @@ public:
         if (!charID)
             return false;
 
+        uint32 id = atoi(charID);
+
+        CreatureTemplate const* creInfo = sObjectMgr->GetCreatureTemplate(id);
+
+        if (!(creInfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT))
+        {
+        char* charID = handler->extractKeyFromLink((char*)args, "Hcreature_entry");
+        if (!charID)
+            return false;
+
         uint32 id  = atoi(charID);
         if (!sObjectMgr->GetCreatureTemplate(id))
             return false;
@@ -297,6 +309,97 @@ public:
 
         sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
         return true;
+        } else {
+        char* charID = handler->extractKeyFromLink((char*)args, "Hcreature_entry");
+        if (!charID)
+            return false;
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_OWNER);
+        //"SELECT owner FROM character_npcbot WHERE entry = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res1 = CharacterDatabase.Query(stmt);
+        if (res1)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `characters_npcbot` table!", id);
+            handler->SendSysMessage("If you want to replace this bot to new location use '.npc move' command");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_BY_ID);
+        //"SELECT guid FROM creature WHERE id = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res2 = WorldDatabase.Query(stmt);
+        if (res2)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `creature` table!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* chr = handler->GetSession()->GetPlayer();
+
+        if (chr->GetTransport())
+        {
+            handler->SendSysMessage("Cannot spawn bots on transport!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        float x = chr->GetPositionX();
+        float y = chr->GetPositionY();
+        float z = chr->GetPositionZ();
+        float o = chr->GetOrientation();
+        Map* map = chr->GetMap();
+
+        if (map->Instanceable())
+        {
+            handler->SendSysMessage("Cannot spawn bots in instances!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* creature = new Creature();
+        if (!creature->Create(map->GenerateLowGuid<HighGuid::Unit>(), map, chr->GetPhaseMaskForSpawn(), id, x, y, z, o))
+        {
+            delete creature;
+            return false;
+        }
+
+        uint8 roleMask = BOT_ROLE_DPS;
+
+        uint8 m_class = creature->GetCreatureTemplate()->trainer_class;
+        if (!(m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE ||
+            m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT ||
+            m_class == CLASS_SHAMAN || m_class == BOT_CLASS_BM))
+            roleMask |= BOT_ROLE_RANGED;
+        if (m_class == CLASS_PRIEST || m_class == CLASS_DRUID ||
+            m_class == CLASS_SHAMAN || m_class == CLASS_PALADIN)
+            roleMask |= BOT_ROLE_HEAL;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+        //"INSERT INTO characters_npcbot (entry, roles) VALUES (?, ?)", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        stmt->setUInt8(1, roleMask);
+        CharacterDatabase.DirectExecute(stmt);
+
+        creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), chr->GetPhaseMaskForSpawn());
+
+        uint32 db_guid = creature->GetSpawnId();
+        if (!creature->LoadBotCreatureFromDB(db_guid, map))
+        {
+            handler->SendSysMessage("Cannot load npcbot from DB!");
+            handler->SetSentErrorMessage(true);
+            //return false;
+            delete creature;
+            return false;
+        }
+
+        sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
+
+        handler->SendSysMessage("Npcbot successfully spawned.");
+        return true;
+    }
     }
 
     //add item in vendorlist
diff --git a/src/server/scripts/Custom/custom_script_loader.cpp b/src/server/scripts/Custom/custom_script_loader.cpp
index 0592bb5..63f2c8e 100644
--- a/src/server/scripts/Custom/custom_script_loader.cpp
+++ b/src/server/scripts/Custom/custom_script_loader.cpp
@@ -215,7 +215,22 @@
 // start197
 // start198
 // start199
-// start200
+//Bots
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_blademaster_bot();
+void AddSC_script_bot_commands();
+//advanced
+//void AddSC_BotQuests_chapter1();
+//end Bots
 
 // The name of this function should match:
 // void Add${NameOfDirectory}Scripts()
@@ -420,5 +435,20 @@ void AddCustomScripts()
 // end197
 // end198
 // end199
-// end200
+    //Bots
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_blademaster_bot();
+    AddSC_script_bot_commands();
+    //advanced
+    //AddSC_BotQuests_chapter1();
+    //end Bots
 }
diff --git a/src/server/scripts/Spells/spell_paladin.cpp b/src/server/scripts/Spells/spell_paladin.cpp
index 6de95af..d5e73d4 100644
--- a/src/server/scripts/Spells/spell_paladin.cpp
+++ b/src/server/scripts/Spells/spell_paladin.cpp
@@ -126,6 +126,12 @@ class spell_pal_ardent_defender : public SpellScriptLoader
             {
                 healPct = GetSpellInfo()->Effects[EFFECT_1].CalcValue();
                 absorbPct = GetSpellInfo()->Effects[EFFECT_0].CalcValue();
+
+                //npcbot - allow for npcbots
+                if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
+
                 return GetUnitOwner()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -140,6 +146,40 @@ class spell_pal_ardent_defender : public SpellScriptLoader
                 Unit* victim = GetTarget();
                 int32 remainingHealth = victim->GetHealth() - dmgInfo.GetDamage();
                 uint32 allowedHealth = victim->CountPctFromMaxHealth(35);
+
+                //npcbot - calc for bots
+                if (victim->GetTypeId() == TYPEID_UNIT/* && victim->ToCreature()->IsNPCBot()*/)
+                {
+                    if (remainingHealth <= 0 && !victim->ToCreature()->GetSpellHistory()->HasCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
+                    {
+                        // Cast healing spell, completely avoid damage
+                        absorbAmount = dmgInfo.GetDamage();
+
+                        uint32 defenseSkillValue = victim->GetDefenseSkillValue();
+                        // Max heal when defense skill denies critical hits from raid bosses
+                        // Formula: max defense at level + 140 (raiting from gear)
+                        uint32 reqDefForMaxHeal  = victim->getLevel() * 5 + 140;
+                        float pctFromDefense = (defenseSkillValue >= reqDefForMaxHeal)
+                            ? 1.0f
+                            : float(defenseSkillValue) / float(reqDefForMaxHeal);
+
+                        int32 healAmount = int32(victim->CountPctFromMaxHealth(int32(healPct * pctFromDefense)));
+                        victim->CastCustomSpell(victim, PAL_SPELL_ARDENT_DEFENDER_HEAL, &healAmount, NULL, NULL, true, NULL, aurEff);
+                        victim->ToCreature()->AddBotSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL, 120 * IN_MILLISECONDS);
+                    }
+                    else if (remainingHealth < int32(allowedHealth))
+                    {
+                        // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
+                        uint32 damageToReduce = (victim->GetHealth() < allowedHealth)
+                            ? dmgInfo.GetDamage()
+                            : allowedHealth - remainingHealth;
+                        absorbAmount = CalculatePct(damageToReduce, absorbPct);
+                    }
+
+                    return;
+                }
+                //end npcbot
+
                 // If damage kills us
                 if (remainingHealth <= 0 && !victim->GetSpellHistory()->HasCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
                 {
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 9e2d265..afa5e3c 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -619,6 +619,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -661,6 +662,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target))
                     {
@@ -807,6 +810,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index e85d205..b795cea 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -3791,6 +3791,128 @@ Metric.OverallStatusInterval = 1
 #
 ###################################################################################################
 
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#    NpcBot.Enable
+#        Description: Enable NpcBot system
+#        Default:   1 - enable
+#                   0 - disable
+
+NpcBot.Enable = 1
+
+#
+#    NpcBot.AllowGM
+#        Description: Allow GM's to have NpcBots
+#        Default:   1 - Allow
+#                   0 - disable
+
+NpcBot.AllowGM = 1
+
+#    NpcBot.MaxBots
+#        Description: Maximum number of bots allowed for players.
+#        Default:   1
+#        Recommend: 1-2
+#        Max:       4
+
+NpcBot.MaxBots = 1
+
+#    NpcBot.MaxBotsPerClass
+#        Description: Maximum bots of each class allowed for players.
+#        Default:   1
+#                   0 - no limit
+
+NpcBot.MaxBotsPerClass = 1
+
+#    NpcBot.BaseFollowDistance
+#        Description: Default bot follow distance.
+#        Note: This parameter determines bots' formation size, distance at which bots will chase and attack enemies.
+#        Note2: This parameter is set for each player at login.
+#        Default:   30
+
+NpcBot.BaseFollowDistance = 20
+
+#    NpcBot.XpReduction
+#        Description: XP percent penalty for each bot used starting with second.
+#        Example: 3 bots, xp reduction is 20: ((3-1)*20) = 40%, 60% exp gained only.
+#        Note: Maximum overall xp reduction is 90%.
+#        Default:   0
+
+NpcBot.XpReduction = 0
+
+#    NpcBot.HealTargetIconsMask
+#        Description: Icon number bitmask which bots use to search for additional targets to heal (out of party).
+#        Note: Many creatures cannot accept heal.
+#        Example: to check Star, Triangle and Square we need 1 + 8 + 32 = 41.
+#        Default:   0 (Disable)
+#                   1 - Star
+#                   2 - Circle
+#                   4 - Diamond
+#                   8 - Triangle
+#                   16 - Moon
+#                   32 - Square
+#                   64 - Cross
+#                   128 - Skull
+
+NpcBot.HealTargetIconsMask = 0
+
+#    NpcBot.Mult.Damage.Melee
+#    NpcBot.Mult.Damage.Spell
+#    NpcBot.Mult.Healing
+#        Description: Multipliers for bots' damage and healing. Allows to balance bots vs players.
+#        Minimum:   0.1
+#        Maximum:  10.0
+#        Default:   1.0
+
+NpcBot.Mult.Damage.Melee = 1.0
+NpcBot.Mult.Damage.Spell = 1.0
+NpcBot.Mult.Healing      = 1.0
+
+#    NpcBot.Enable.Dungeon
+#    NpcBot.Enable.Raid
+#    NpcBot.Enable.BG
+#    NpcBot.Enable.Arena
+#    NpcBot.Enable.DungeonFinder
+#        Description: Allow bots to enter PvE/PvP areas and Dungeon Finder query
+#        Default:   1 - (NpcBot.Enable.Dungeon)
+#                   0 - (NpcBot.Enable.Raid)
+#                   0 - (NpcBot.Enable.BG)
+#                   0 - (NpcBot.Enable.Arena)
+#                   1 - (NpcBot.Enable.DungeonFinder)
+
+NpcBot.Enable.Dungeon       = 1
+NpcBot.Enable.Raid          = 0
+NpcBot.Enable.BG            = 0
+NpcBot.Enable.Arena         = 0
+NpcBot.Enable.DungeonFinder = 1
+
+#    NpcBot.Limit.Dungeon
+#    NpcBot.Limit.Raid
+#        Description: Enable/Disable instance players limitation rules for bots.
+#        Default:   1 - (NpcBot.Limit.Dungeon)
+#                   1 - (NpcBot.Limit.Raid)
+
+NpcBot.Limit.Dungeon = 1
+NpcBot.Limit.Raid    = 1
+
+#    NpcBot.Cost
+#        Description: Bot recruitment cost (in copper).
+#        Note: This value is for level 80 characters.
+#              Cost is reduced for lower levels by simple formula: (cost * level / 80).
+#        Default:   1000000 (100 gold, 1g25s at level 1)
+
+NpcBot.Cost = 1000000
+
+#    NpcBot.PvP
+#        Description: Allow bots to attack player-controlled units (players, pets, bots, etc.)
+#        Note: This rule only applies to player-controlled bots
+#        Default:   1
+
+NpcBot.PvP = 1
+
+#
+###################################################################################################
+
 #
 # Prepatch by LordPsyan.
 # See http://www.realmsofwarcraft.com/bb for forums and information.
-- 
2.1.4

